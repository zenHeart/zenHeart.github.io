(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{268:function(t,n,a){t.exports=a.p+"assets/img/tool_v81.ca1db3d6.png"},269:function(t,n,a){t.exports=a.p+"assets/img/tool_v82.53e725ad.png"},347:function(t,n,a){"use strict";a.r(n);var s=a(4),e=Object(s.a)({},function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"v8"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8","aria-hidden":"true"}},[t._v("#")]),t._v(" v8")]),t._v(" "),s("p",[s("strong",[t._v("汇总 v8 资料")])]),t._v(" "),s("h2",{attrs:{id:"环境配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#环境配置","aria-hidden":"true"}},[t._v("#")]),t._v(" 环境配置")]),t._v(" "),s("p",[t._v("参看 github v8 项目说明。"),s("a",{attrs:{href:"https://github.com/v8/v8/wiki/Building%20from%20Source",target:"_blank",rel:"noopener noreferrer"}},[t._v("V8 wiki"),s("OutboundLink")],1)]),t._v(" "),s("ol",[s("li",[t._v("安装 git")]),t._v(" "),s("li",[t._v("安装 depot_tools,是用来管理 chrome 项目的脚本工具。"),s("a",{attrs:{href:"https://www.chromium.org/developers/how-tos/depottools",target:"_blank",rel:"noopener noreferrer"}},[t._v("depot 使用说明"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"js-执行原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-执行原理","aria-hidden":"true"}},[t._v("#")]),t._v(" js 执行原理")]),t._v(" "),s("p",[t._v("js 是解释型语言,相比类似 c,c++ 等编译型语言执行原理有区别.")]),t._v(" "),s("p",[t._v("c 语言的文本流进入编译器")]),t._v(" "),s("ol",[s("li",[t._v("前期准备\n编译器根据自身的配置选项决定编译特性")]),t._v(" "),s("li",[t._v("预处理,替换宏定义")]),t._v(" "),s("li",[t._v("编译将语言编译成机器码")]),t._v(" "),s("li",[t._v("连接,将可执行文件拷贝到源码中")])]),t._v(" "),s("p",[t._v("对于 js 解释性语言执行流程如下.")]),t._v(" "),s("p",[t._v("虚拟机,类似编译器是一个实时运行的程序用来将输入流\n翻译成可执行的代码.")]),t._v(" "),s("ol",[s("li",[t._v("词法分析将输入的字符串或文件翻译成词法流")]),t._v(" "),s("li",[t._v("语法分析将内容解析为语法流.")]),t._v(" "),s("li",[t._v("预解析阶段,处理函数变脸的申明")])]),t._v(" "),s("p",[t._v("V8 引擎不同于普通的解释器，它是一个实时编译器,JIT(just in time) compiler，\n直接将 js 脚本翻译成机器代码进行执行。不同于其它解释器产生中间代码在进行编译。")]),t._v(" "),s("p",[t._v("JS 是基于原型继承的语言，没有类的概念，对象利用克隆的方法被创建，js 还是一种\n动态类型的语言。类型和属性信息可以随时被修改。为了加快获取对象的属性，v8 并没有使用\n字典结构去索引属性，而是在内部创建了一个隐藏类，去描述系统的类型，提升属性的获取速率。")]),t._v(" "),s("p",[t._v("引擎动态编译流程分析")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("函数的执行"),s("br"),t._v("\n假设我们创建了如下函数")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Point")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("利用 new 创建新的类"),s("br"),t._v("\n当利用 new 语句创建 "),s("code",[t._v("new Point(x,y)")]),t._v(" 时,v8 创建了一个属于 Point 的隐藏类，利用该隐藏类创建了 Point 对象。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://developers.google.com/v8/images/map_trans_a.png",alt:""}}),s("br"),t._v("\n当引擎执行 "),s("code",[t._v("this.x = x;")]),t._v(" 时，由于对象创建了一个新属性，引擎会创建另外一个隐式类 C1，基于 C0，重新创建对象 Point。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://developers.google.com/v8/images/map_trans_b.png",alt:""}}),s("br"),t._v("\n当执行下一句时，方法同上")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://developers.google.com/v8/images/map_trans_c.png",alt:""}}),s("br"),t._v("\n这样每当有新的对象产生时，若来自同一对象可以复用隐藏类。 这样的好处在于你不需要去进行字典索引，利用隐藏类实现查找。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(268),alt:""}}),t._v("\n如上图，利用 Point 为构造函数，利用 new 指令创建了两个对象，p 和 q。"),s("br"),t._v("\n他们都指向隐藏类来获取属性。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(269),alt:""}}),t._v("\n再来看一下图例二,我们在对象 q 上动态添加了一个属性 z,v8 引擎创建了一个新的隐藏类，\n每当构造器函数申明一个新属性，同时保持对变化的隐藏对象的跟踪，具体的步骤如下")])]),t._v(" "),s("li",[s("p",[t._v("构造器产生对象时，v8 引擎在后台创建了隐藏类")])]),t._v(" "),s("li",[s("p",[t._v("当已创建的对象添加新属性时，v8 引擎在后台添加了新的隐藏类，重新创建对象 q ,并且保持原来的类和\n当前隐藏类。其中表示如图，虚线为隐式连接，实现为显示引用。每当创建一个新的隐藏类的时候，如图可以看出，\n隐式指针会替换到新创建的隐藏类上面，同时利用该隐藏类创建新的实体对象。")])])]),t._v(" "),s("p",[t._v("v8 如何编译 js 源码,内联缓存机制和隐式类")]),t._v(" "),s("ol",[s("li",[t._v("每一个虚拟运行环境，都会包含一个隐藏类关联每一个对象")]),t._v(" "),s("li",[t._v("如果对象的布局发生了变化，运行环境会创建一个新的隐藏类，符合这个新的布局，并且关联到这个对象上。")])]),t._v(" "),s("p",[t._v("JS 的内存管理"),s("br"),t._v("\n不同于 C 语言，需要手动分配和释放内存，在高级语言中内存的分配和调度由引擎实现。"),s("br"),t._v("\n其中内存的分配及自动回收的机制被称为垃圾回收。下面我们详细讲解 js 引擎是如何创建和销毁内存的。")]),t._v(" "),s("p",[t._v("内存的生命周期流程")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("分配你所需要的内存")])]),t._v(" "),s("li",[s("p",[t._v("使用分配的内存")])]),t._v(" "),s("li",[s("p",[t._v("不需要时释放内存"),s("br"),t._v("\n对于低级语言上述步骤由程序员手动创建并销毁，而在高级语言中上述过程会被引擎进行隐藏，它会自动进行回收。"),s("br"),t._v("\n但这并不意味着作为编程者就可以忽略其中的原理，只有理解了引擎创建和销毁内存的机制，才能更好地使用这些机制，\n实现更高性能的代码。")])]),t._v(" "),s("li",[s("p",[t._v("内存分配"),s("br"),t._v("\n在 js 中所有的变量类型可分为基本类型和引用类型两大类，对于基本类型，每当变量创建时就会完成内存分配。"),s("br"),t._v("\n存在哪里？")])]),t._v(" "),s("li",[s("p",[t._v("内存销毁"),s("br"),t._v("\n对于基本的数值变量，当其运行环境脱离其作用域时，就会被自动销毁。而对于引用变量，则不同。"),s("br"),t._v("\n首先在 js 中存在隐式引用和显示引用两种方式，隐式引用是为了实现 js 的原型链继承，利用内部的 "),s("em",[t._v("prot")]),t._v(" 实现的。\n对于程序员最好不要手动控制它。而显示引用是指程序员在未利用 new 的手段创建新对象时，单纯的将一个对象复制给另一个变量。"),s("br"),t._v("\n这种当时变回形成显示引用。对于大多数程序内存占用的问题，就来源于我们错误的创建方式和不健全的引用方式造成的。")])])]),t._v(" "),s("p",[t._v("对于引用类型的变量，引擎利用垃圾回收机制来实现对内存的释放。主要有如下两种方法")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("计数器回收机制"),s("br"),t._v("\n每当对象有调用时就给该对象的引用计数上加 1，知道对象引用计数为 0 时，清楚对象内存。"),s("br"),t._v("\n问题及限制：")]),t._v(" "),s("ol",[s("li",[t._v("循环引用在变量脱离执行环境后无法被回收")])])]),t._v(" "),s("li",[s("p",[t._v("标记清除算法"),s("br"),t._v("\n从对象的根节点开始，遍历所有对象找出所有在节点结构上的的对象和引用对象，及脱离根结构的对象。清楚所有不属于根结构的内存。"),s("br"),t._v("\n这种方法就避免了循环引用时出现的问题。")])]),t._v(" "),s("li",[s("p",[t._v("V8 垃圾回收运行步骤")]),t._v(" "),s("ol",[s("li",[t._v("暂停程序执行在垃圾回收时")]),t._v(" "),s("li",[t._v("只处理对象堆，保证对应用的暂停产生最小的影响")]),t._v(" "),s("li",[t._v("确切的知道对象指针的内存映射，避免错误的标识对象指针所引起的内存泄漏")])])])]),t._v(" "),s("p",[t._v("在 V8 引擎中，对象堆被分为两部分，当对象创建时分配的新空间和在垃圾回收中被保留的对象空间。"),s("br"),t._v("\n在下一次垃圾回收时，将会更新所有对象的指针。")]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[t._v("堆和栈"),s("br"),t._v("\n我们知道引擎在工作时变量会被分配到两种类型的内存，"),s("code",[t._v("堆")]),t._v("和"),s("code",[t._v("栈")])])]),t._v(" "),s("ul",[s("li",[t._v("栈"),s("br"),t._v("\n是一个连续的内存段，用来保存函数的执行环境，利用一下代码可以测试，js 引擎支持多少层的栈调用")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'counter ='")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" counter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//result->   counter = 20824")]),t._v("\n")])])]),s("p",[t._v("增加函数中的变量如下")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" local "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'counter ='")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" counter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//result->  counter = 17849")]),t._v("\n")])])]),s("p",[t._v("利用如下公式计算栈大小")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("N - size of single stack frame\n20824 * N = 17849 * (N + 8)\n(20824 - 17849) * N = 17849 * 8\n2994 * N = 143736\nN = 143736 / 2994 = 48 bytes = 6 numbers\nTotal stack size = 20824 * 48 = 122KB < 1MB\n")])])]),s("p",[t._v("重点在下面目前我已经知道了栈的大小，在添加一个变量你就可以预测，下一个执行次数了。"),s("br"),t._v("\n通过上面的例子我们认识到了栈的执行大小，现在讨论函数嵌套，和异步事件的栈执行。"),s("br"),t._v("\n对于函数嵌套例子同上，引擎不断的加执行环境压如栈中。"),s("br"),t._v("\n在有异步事件的时候，浏览器内部有一个事件循环，每当有事件触发时，就会产生一个回调函数的执行队列。"),s("br"),t._v("\n当运行完当前函数栈以后，异步回调被压入执行环境进行执行。执行栈按照事件顺序逐一触发执行。"),s("br"),t._v("\n事件队列的任务就是，循环扫描触发事件，发事件放入执行队列，在当前栈空间执行完毕后，执行新的任务队列。"),s("br"),t._v("\n这也是原来讲的先执行同步事件，在执行异步结果的原因。"),s("br"),t._v("\n可以这么认为，在当前有执行栈的情况下，异步事件的回调任务会被压如执行栈，但是永远不会执行。"),s("br"),t._v("\n除非此时主线程的执行栈为空时才可以！")]),t._v(" "),s("ul",[s("li",[t._v("堆"),s("br"),t._v("\n用来存储一切被动态调用的动态资源，通过栈的例子我们明白了栈只保存变量类型，下面再看一个例子")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" local "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      foo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'foo'")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'counter ='")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" counter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//result->  counter = 17849")]),t._v("\n")])])]),s("p",[t._v("结果没有发生任何变化，理论上来说，局部变量变成对象，次数应该减少。只有局部变量被存储在每一层栈中。"),s("br"),t._v("\n所指向的变量被分配到了堆中，同样对于函数等通过引用的方式传递的参数也是如此。")]),t._v(" "),s("p",[t._v("所有属性的引用都会以字符串的形式存储，所以在引用对象时"),s("br"),t._v(" "),s("code",[t._v("object[1]")]),t._v("、"),s("code",[t._v("object['1']")]),t._v("、"),s("code",[t._v("object[1.0]")]),t._v("是一样的")]),t._v(" "),s("p",[t._v("##　scope 和 context\n变量作用域和变量执行环境的概念不一样。函数在运行时他们两个同时存在。"),s("br"),t._v("\n作用域是指，变量可被调用的范围，它和变量的申明方式和所处环境有关，例如全局变量就是指\n在整个程序的运行作用域可以被调用的量。而执行环境是指当前程序所运行的状态，它等于\n"),s("code",[t._v("this")]),t._v(" 指针，表示了目前程序在运行时所处的空间。和栈的状态有关。")]),t._v(" "),s("h2",{attrs:{id:"作用域句柄"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域句柄","aria-hidden":"true"}},[t._v("#")]),t._v(" 作用域句柄")]),t._v(" "),s("p",[t._v("句柄用来表示指向 V8 引擎，对空间对象的指针，每当垃圾回收器执行时，对象的空间可能发生变化。"),s("br"),t._v("\n这时句柄的引用之会发生改变。句柄有如下几种类型:")]),t._v(" "),s("ol",[s("li",[t._v("本地句柄，保留在栈空间中。当对象创建时就会产生。")]),t._v(" "),s("li",[t._v("作用域句柄，在函数调用的开始被创建。当作用域句柄取消时，垃圾回收机器将会释放，所有和作用域句柄有关的对象空间。")]),t._v(" "),s("li",[t._v("保持句柄，对 javascript 的堆调用提供引用。用来保存一个状态，不会被垃圾回收主动销毁。")])]),t._v(" "),s("p",[t._v("根据下面这张图我们详细讲解一下，当调用一个函数时发生了什么")]),t._v(" "),s("img",{staticStyle:{background:"white"},attrs:{src:"https://developers.google.com/v8/images/local_persist_handles_review.png"}}),t._v(" "),s("ol",[s("li",[t._v("每当执行到一个新的函数时，会在栈空间创建作用域句柄")]),t._v(" "),s("li",[t._v("同时引擎在对空间创建了执行环境的对象，并将引用传递给栈空间的本地句柄")]),t._v(" "),s("li",[t._v("产生一个持久句柄保存作用域句柄和执行环境句柄")]),t._v(" "),s("li",[t._v("每当新建一个变量，在堆中创建对象，并将句柄返回给变量")]),t._v(" "),s("li",[t._v("编译这个本地环境的代码，生成一个执行脚本。")]),t._v(" "),s("li",[t._v("最后执行该脚本，在堆中创建结果的对象，返回引用")]),t._v(" "),s("li",[t._v("若调用了作用域句柄的析构函数，作用域对应的栈和引用的对象都会被销毁。")]),t._v(" "),s("li",[t._v("注意其中生成的源码对象和脚本对象，在没有被引用时也会被销毁。注意保持句柄的栈和堆空间是独立的，\n只有当内部调用 reset 函数时才会被回收。")])]),t._v(" "),s("h2",{attrs:{id:"执行环境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行环境","aria-hidden":"true"}},[t._v("#")]),t._v(" 执行环境")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://developers.google.com/v8/images/intro_contexts.png",alt:""}}),s("br"),t._v("\n执行环境，看上图可知，执行环境可以嵌套，利用 exit 和 enter 实现执行环境之间的切换。")]),t._v(" "),s("h2",{attrs:{id:"在调试-js-代码时注意看错误的前缀"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在调试-js-代码时注意看错误的前缀","aria-hidden":"true"}},[t._v("#")]),t._v(" 在调试 js 代码时注意看错误的前缀")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"left"}},[t._v("错误类型")]),t._v(" "),s("th",[t._v("含义")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("SyntaxError")]),t._v(" "),s("td",[t._v("语法错误，语法或词法解析器无法解析代码")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("ReferenceError")]),t._v(" "),s("td",[t._v("索引错误，无法搜索到变量地址")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("TypeError")]),t._v(" "),s("td",[t._v("使用错误，对应属性不具有相关操作")])])])]),t._v(" "),s("h2",{attrs:{id:"编译-v8"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译-v8","aria-hidden":"true"}},[t._v("#")]),t._v(" 编译 v8")]),t._v(" "),s("ul",[s("li",[t._v("[ ] "),s("a",{attrs:{href:"https://gist.github.com/kevincennis/0cd2138c78a07412ef21",target:"_blank",rel:"noopener noreferrer"}},[t._v("mac 编译 v8"),s("OutboundLink")],1)]),t._v(" "),s("li",[t._v("[ ] "),s("a",{attrs:{href:"https://github.com/v8/v8/wiki/Building-from-Source",target:"_blank",rel:"noopener noreferrer"}},[t._v("build v8"),s("OutboundLink")],1)]),t._v(" "),s("li",[t._v("[ ] "),s("a",{attrs:{href:"http://www.mattzeunert.com/2017/01/30/lazy-javascript-parsing-in-v8.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("v8 parser"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.6386&rep=rep1&type=pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("JIT 垃圾回收论文"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"http://newhtml.net/v8-garbage-collection/",target:"_blank",rel:"noopener noreferrer"}},[t._v("v8 垃圾回收机制"),s("OutboundLink")],1),t._v(" "),s("a",{attrs:{href:"https://github.com/goddyZhao/GPosts/blob/master/javascript/%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E9%80%94%E5%BE%84%E8%83%BD%E5%A4%9F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JavaScript%E8%A7%A3%E6%9E%90%E5%BC%95%E6%93%8E%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何理解 js 引擎"),s("OutboundLink")],1)])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://gun.io/blog/reimplementing-javascript/",target:"_blank",rel:"noopener noreferrer"}},[t._v("重解 javascript,理解工作原理"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://medium.com/dailyjs/javascript-basics-the-execution-context-and-the-lexical-environment-3505d4fe1be2",target:"_blank",rel:"noopener noreferrer"}},[t._v("词法环境和执行环境"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://www.html5jscss.com/js-data-scope.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("js 执行详解"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://developers.google.com/v8/design?csw=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("v8 引擎工作原理"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/",target:"_blank",rel:"noopener noreferrer"}},[t._v("V8 引擎工作原理"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("内联缓存和隐藏类"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management",target:"_blank",rel:"noopener noreferrer"}},[t._v("js 内存管理"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://blog.niftysnippets.org/2008/02/closures-are-not-complicated.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("闭包的原理"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://www.jianshu.com/p/4c74a19ad03b",target:"_blank",rel:"noopener noreferrer"}},[t._v("堆和栈是什么"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://bahmutov.calepin.co/javascript-stack-size.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("js 的堆和栈"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://mrale.ph/v8/resources.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("v8 引擎资源"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://blog.niftysnippets.org/2008/02/closures-are-not-complicated.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("闭包并不复杂"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://www.programmerinterview.com/index.php/data-structures/difference-between-stack-and-heap/",target:"_blank",rel:"noopener noreferrer"}},[t._v("堆和栈的区别"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://ryanmorr.com/understanding-scope-and-context-in-javascript/",target:"_blank",rel:"noopener noreferrer"}},[t._v("作用域和执行环境"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://developers.google.com/v8/embed",target:"_blank",rel:"noopener noreferrer"}},[t._v("作用域句柄"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://developers.google.com/v8/embed",target:"_blank",rel:"noopener noreferrer"}},[t._v("嵌入 V8 引擎指导"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"http://www.cnblogs.com/pugang/archive/2012/04/02/2430519.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("v8 调试"),s("OutboundLink")],1),t._v(" "),s("a",{attrs:{href:"https://cs.chromium.org/chromium/src/v8/",target:"_blank",rel:"noopener noreferrer"}},[t._v("v8 API"),s("OutboundLink")],1),t._v(" "),s("a",{attrs:{href:"https://developers.google.com/v8/",target:"_blank",rel:"noopener noreferrer"}},[t._v("v8"),s("OutboundLink")],1),t._v(" "),s("a",{attrs:{href:"https://github.com/danbev/learning-v8",target:"_blank",rel:"noopener noreferrer"}},[t._v("学习 v8 github"),s("OutboundLink")],1)])])},[],!1,null,null,null);n.default=e.exports}}]);