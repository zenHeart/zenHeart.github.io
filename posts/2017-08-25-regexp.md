# 正则表达式
**前言：讲解正则表达式的基本使用**

---


## 正则表达式使用详解
使用正则表达式的作用
1. 实现复杂文本逻辑的替换
2. 查找文本模式
3. 提取文本模式


```html
    <!doctype html>
    <html ng-app="MyModule">
    	<head>
    		<meta charset="utf-8">
    		<link rel="stylesheet" href="css/bootstrap-3.0.0/css/bootstrap.css">
    	</head>
    	<body>
    		<div ng-controller="MyCtrl">
    			<greeting greet="sayHello(name)"></greeting>
    			<greeting greet="sayHello(name)"></greeting>
    			<greeting greet="sayHello(name)"></greeting>
    		</div>
    		<p>number:123-3456-7923</p> 
    		 <p>hello hello hello   hello   hello   </p>
    	</body>
    	<script src="framework/angular-1.3.0.14/angular.js"></script>
    	<script src="ScopeAnd.js"></script>
    </html>
```

### 匹配模式空行  
**注意:在使用正方向预查时，注意预查信息要保证唯一性，及预查模式不存在此时匹配的情况。**   
**也不能出现模式嵌套**

```regexp
(?<=\n)\s*\n  //匹配空行
^\s\s$        // 匹配规则同上  
```

涉及知识点

| 正则符号       | 作用                                                                            |
| :------------- | :------------------------------------------------------------------------------ |
| `(?<=pattern)` | 限定搜索字符串前的限制条件，比如范例中`(?<=\n)\s`，只搜索前面是换行符的空白字符 |
| `*`            | 表示前面内容重复0到多次，类似`{0，}`，比如 `\s*` 匹配多个或没有空白             |
| `^`            | 表示一行输入字符串开始位置，`^\s`,搜索以空白符开始的行                          |
| `$`            | 表示一行输入字符串结束位置，`\s$`，搜索以空白字符结束的行                       |
| `\s`           | 单个空白字符，和`[\f\n\r\t\v]` 相同                                             |

### 匹配 5 个字母的单词

```regexp
\b[[:alpha:]]{5}\b 
```

| 正则符号      | 作用                                                    |
| :------------ | :------------------------------------------------------ |
| `[[:alpha:]]` | 表示一个字母                                            |
| `{n}`         | 表示前面的内容重复5次，`a{5}`,搜索5个相同字母a 的字符串 |
| `\b`          | 匹配单词的边界的位置                                    |


### 匹配一个尖括号内的内容
```regexp
(?<=<).*?(?=>)
```

| 正则符号 | 作用                                                                                                          |
| :------- | :------------------------------------------------------------------------------------------------------------ |
| `(?=>)`  | 正向肯定预查，限定字符串后面的搜索条件，`(?=>)`表示搜索字符内容后面必须有>符号                                |
| `?`      | 当 `?` 跟在`*，{n,m},+` 等次数符后面时，表示以最少字符串数量匹配限定条件,默认的是贪婪算法及尽可能多的匹配字符 |
| `.`      | 表示除`\n` 外所有字符                                                                                         |


### 匹配电话号码
```regexp
\d{3}(-\d{4}){2}
```

| 正则符号 | 作用                           |
| :------- | :----------------------------- |
| `\d`     | 表示 0-9 的数字，类似于`[0-9]` |
| `{n}`    | 重复前面的模式 n 次            |


## 后向引用
当我们利用括号进行字符匹配的时候存在两种情况
 1. 只搜索匹配的模式，匹配的模式不会缓存
 2. 搜索到匹配模式后，将匹配模式的的字符串进行缓存

对于模式以，一般是将就的内容整个覆盖为新内容，而模式二则是对旧的内容做部分更改，
及在保留部分原格式的基础上，插入信的格式，此时在替换时就需要利用缓存的内容来进行更新。

对于所有加括号内容，都会实现缓存。缓存的规则如下
1. 从左到右，以分组的左括号为标记，每出现一次左括号，分组序号加1
2. 对于每个匹配的字符串模式，都包含这样一个分组数组，用于保存模式匹配内容
3. 利用 `\n` 表示每个匹配字符串对应的，分组内容
4. 在实现第二种替换时，利用 `$n` 来表示分组替换模式

其中 `\n` 的模式匹配比较难与理解简单讲述一下

```regexp
查找内容:((\bhello\b)\s+)\1
替换内容:$1
```

1. 由于出现左括号变代表分组，所以每个匹配字符串会保存两个分组
2. 分组1 -> 最外面的大括号匹配的字符串内容，表示后面有空白的 hello 单词
3. 分组2 -> 内层括号匹配的字符串内容，表示hello单词
4. 由于匹配模式后面带有\1，它表示重复步骤2中的分组结果，及后面带有空白的 hello 字符，
5. $2 替换第4步搜索到的字符串内容，为第1个分组中的内容

| 正则符号       | 作用                                                                        |
| :------------- | :-------------------------------------------------------------------------- |
| `(exp)`        | 搜索括号中模式，并保存到分组中</td>                                         |
| `(?<name>exp)` | 将匹配模式内容，保存到名字为name的分组中，也可以使用(?'name'exp)的模式</td> |
| `(?:exp)`      | 搜索括号中模式，不保存到分组内容</td>                                       |
| `(?=exp)`      | 正向肯定预查，匹配 exp 后面的位置</td>                                      |
| `(?<=exp)`     | 反向肯定预查，匹配 exp 前面的位置</td>                                      |
| `(?!exp)`      | 正向否定预查，匹配不是 exp 后面的位置</td>                                  |
| `(?<!exp)`     | 反向否定预查，匹配不是 exp 前面的位置</td>                                  |
| `(?#comment)`  | 正则表达式中的注释来描述匹配规则，对匹配不产生影响</td>                     |

    
## 正则使用配置项

<table cellspacing="0">
<thead>
<tr>
<th scope="col">名称</th>

<th scope="col">说明</th>
</tr>

</thead>
<tbody>
<tr>
<td>IgnoreCase(忽略大小写)</td>
<td>匹配时不区分大小写。</td>
</tr>
<tr>
<td>Multiline(多行模式)</td>

<td>更改<span class="code">^</span>和<span class="code">$</span>的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,<span class="code">$</span>的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) </td>
</tr>
<tr>
<td>Singleline(单行模式)</td>
<td>更改<span class="code">.</span>的含义，使它与每一个字符匹配（包括换行符\n）。 </td>

</tr>
<tr>
<td>IgnorePatternWhitespace(忽略空白)</td>
<td>忽略表达式中的非转义空白并启用由<span class="code">#</span>标记的注释。</td>
</tr>
<tr>
<td>ExplicitCapture(显式捕获)</td>
<td>仅捕获已被显式命名的组。</td>
</tr>
</tbody>
</table>
  
## 平衡组递归匹配
替换模式
利用 \L或\l 实现对匹配组字符大小写的转换。
    


## 正则的基本介绍
正则是用来对文本进行模式匹配的语法。


## 正则回归陷阱
[正则陷阱](http://mp.weixin.qq.com/s/OtVRL37CNt_d5yEJPzzBzg)

## 资料
[regexp 学习](http://www.regexlab.com/zh/regref.htm)
