网络安全概论
===
---
_前言：讲解网络安全的基本概念_
## 概述
安全是一个很宽泛的的概念，这里讲解的网络安全属于**[信息安全](https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8)**的一个子集。

本章包含信息安全中**访问控制**和**密码学**两大部分的内容。


## 通讯安全
### 对称加密
假设A 和 B 用户之间要通讯，流程如下

    A --hello world----> B


这里的`hello world`就是**明文 P**(plaintext)，因为这种信息大家都可以理解。

但是在传输过程中若出现如下情况：

    A --明文----> B
            └--> C
C 通过某种手段获取到 A 和 B 之间的明文消息，这种手段叫做**截获**属于**被动攻击**

现在 A 和 B 之间希望通讯可以保证安全性，即使 C 截获了这个信息也无法理解其中的内容。

所以 A 和 B 之间采用如下方式通讯

    A--加密明文---->B

这里加密的明文就是**密文 C**(ciphertext)，那么明文到密文是如何实现的呢？

明文到密文类似数学的函数`y = f(x)` _x_ 就是输入的明文，_y_ 就是输出的密文。

而这里的函数`f()`就是我们的**加密算法 E**(encryption)。

同理，对于 B 他需要把 A 发送的密文先进行解密才能读懂信息，此时会存在另一个函数`x= g(y)`这里输入是密文，输出是明文，g()就是**解密函数 D**(decryption)。
由于解密可以理解为加密的反函数，所以后续当我们谈到加密算法的时候，实际上就是指整个加解密的过程。

所以整个发送流程如下

    A 发送前 明文 P -> 加密函数 E -> 密文 C
    A ---密文 C ----> B
    B 接收后 密文 C -> 解密算法 D -> 明文 P

上述过程存在的问题是，加解密算法如何约定，而且这个函数本身如何只让双方知道，不可能让每一个会话之间，定义自己的加解密算法。

所以在加解密函数中我们又多了一个参数叫做**秘钥 K**,这时加密函数变为:`C=E(P,K)`,解密函数变为:`P=D(C,K)`,
而这种广为大家使用，能够利用 K 来改变密文形态的加解密过程就是各种加密算法。这时大家只需采用公开的加密算法，保护好自己的秘钥即可。
这里还有一个问题是在开始通讯之前，秘钥 K 是如何约定的，因为它是加密其他明文的初始条件,目前我们暂不讨论！

在拥有加密算法，同时 K 已经约定好的前提下，整个通讯的流程如下

    A 发送前 明文 P -> K + 加密函数 E -> 密文 C
    A ---密文 C ----> B
    B 接收后 密文 C -> K + 解密算法 D -> 明文 P

假设在此时发生了同样的截获事件

    A 发送前 明文 P -> K + 加密函数 E -> 密文 C
    A ---密文 C ----> B
                └--> 截获者 J
    B 接收后 密文 C -> K + 解密算法 D -> 明文 P

此时对于 J 它只知道密文和加解密算法，但是无法获取关键的秘钥，
理论上它可以尝试穷举所有可能的结果来找出 K,这被称为**暴力破解**，所以为了增加破解的难度，
一般秘钥会很长，常见的是 128 位、256 位 或者更高。由于 A 和 B 之间的秘钥 K 都相同，所以我们称为**对称秘钥加密技术**。
常见的对称秘钥加密技术包括
1. [AES](https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86)
2. [DES](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96)

利用对称加密我们解决了通讯中的安全问题，回到前面搁置的地方
1. 如何传递对称加密中的约定秘钥 K？其次由于加解密使用同样的秘钥，破解了 K 就控制了整个通讯!
2. 假设有 N 个相互通讯的节点，若收发均利用一个单独的秘钥 K,则存在 N*(N-1) 对秘钥，如何管理这些秘钥？
为了解决上述问题。出现了**非对称加密**也叫**公开秘钥加密**。

### 非对称加密
非对称加密的原理如下。
1. 对话之间的加密和解密的秘钥不同。
2. 独自持有的密钥称为**私钥 SK**(secret key)、公开发布的秘钥称为**公钥 PK**(public key)

根据上面两条原则可以得出公钥既可能是加密秘钥也可能是解密秘钥，我们先讨论加密秘钥是公钥的情况
，节点之间发送和接收的流程如下：

        A 和 B、C、D 通讯：
        A ------ PKb 加密 ----> B(SKb 解密)
            └--- PKc 加密 ----> C(SKc 解密)
            └--- PKd 加密 ----> D(SKd 解密)

        B、C、D 和 A 通讯：
        B--(PKa 加密)----┓
        C--(PKa 加密)-----┈>A(SKa 分别解密三段密文)
        D--(PKa 加密)----┛

相比对称秘钥，由于解密秘钥 SK 为私钥，而加密秘钥 PK 为公钥，就避免了约定和传递秘钥 K 的过程。
但是我们来分析如下的通讯情况：

        A 和 B 通讯：
        A---(PKb加密)-┈>B(SKb 分别解密三段密文)

        C 作为中间人的通讯
        A--(PKc 加密)-->C(PKc 解密)--(PKb加密)-┈>B(SKb 分别解密三段密文)

在 A 和 B 的通讯之间，我们插入了一个用户 C,它利用自己的公钥来替换 PKb 的公钥，这种手段叫做**中间人攻击**。
为了避免这种问题，我们需要在 A 和 B 之间进行认证，这叫做**鉴别**。

### 数字签名
前面我们讨论的问题都是如何保证消息传递的安全性，总结一下：
1. 为了防止第三方截获明文，A 和 B 之间利用对称加密进行通讯。
2. 为了解决对称加密中节点激增和秘钥传递的问题创造了非对称加密(加密秘钥公开)。

目前的问题在于如何解决加密秘钥公开的非对称加密中出现的中间人欺骗，这里我们引入了**签名算法**,和
**摘要算法**，他们的目的在于验证通讯双方是真实可信的。(实际上签名算法本身就是非对称加密算法，这里的目的只是为了功能区分，
签名算法主要的目的是用来识别和认证通讯的对象，而加密算法是为了通讯的安全！)

利用非对称秘钥中解密秘钥为公钥的手段可以实现这种验证。在这里验证流程如下:


    B--（明文 + 报文摘要 + SKb 加密的摘要（数字签名））-----> A (PKb 解密数字签名得到摘要，和收到的明文生成的摘要比较进行验证 )

这涉及几个概念，**报文摘要**是指对整个报文利用摘要算法生成一个哈希值，而**数字签名**就是把报文摘要利用私钥加密后得到的数据，
接收方利用摘要算法把明文重新转换成摘要，再与数字签名的解密结果比较就可以验证消息是从 A 发出的，并且当发送明文有缺失时或被篡改时，会导致
生成的摘要不同，利用这一点可以验证信息的完整性。由于非对称加密耗时较长，所以将明文进行摘要算法后再加密更好。常见的摘要算法包括：
1. [MD5](https://zh.wikipedia.org/wiki/MD5)
2. [SHA 家族](https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)

这里的消息传输是只起到验证的作用，中间人可以直接利用公钥 PKb 获取到 B 发送的明文(虽然这里的明文没有价值)，如何保证
验证的私密性，可以将流程概括如下：

    B -- (SKb 加密) -- （PKa 加密） ---> A (SKa 解密后利用 PKb解密)

由于这里的 SKb 和 SKa 对于中间人来说都是不可见的，所以就保证了 C 即使截获了数据，也无法得出明文内容。

分析上面的问题，可知对于非对称秘钥 A 和 B 之间需要分别保存对方的公钥和自己的私钥，如何保证公钥的权威性，谁来管理公钥的分发，验证通讯用户的合法性。
这里就出现了**数字证书**的概念，数字证书可以理解为用户或组织的 ID,通过第三方**数字证书认证机构 CA**来对通讯对象进行担保。数字证书的格式如下图

![](img/network1.jpg)

验证流程如下：

    B--（数字证书 + 报文摘要 + SKb 加密的摘要（数字签名））-----> A (PKb 解密数字签名得到摘要，和自己的数字证书的摘要比较进行验证)


综合分析以上问题，对称加密简单有效，但无法解决秘钥的约定问题，非对称加密安全性更高，但是计算复杂，会减慢通讯速率，
考虑到这些就出现了结合对称加密和非对称加密的**混合系统**。

### 混合系统

### 其他安全问题
消息重放，当中间人截获该消息后，不作任何操作，重放该会话，如何阻止这种情况。
此时会在数字签名中加入随机量来防止重放，常见手段如下：
1. 时间戳
在数字签名中加入时间戳，接收方只允许某一个时间段的接收时差。
2. 消息 ID
每次会话只存在唯一的消息 ID,发送时利用他来识别会话的唯一性。
3.

### 在设计 API 是的步骤
1. 思考你的威胁模型是什么
* API 的哪些值会造成危害
* 如何进行完整性和安全性的数据验证

2. 脚本注入
禁止外界传入的参数，存在执行的可能性，你只能接受字符串或数据流，不要考虑
直接运行客户端传来的对象，这非常危险。

## 加盐哈希

[加盐哈希算法](http://blog.jobbole.com/61872/)


